# Gráficos de la serie en escala original
win.graph(); plot(Datos5, main = "Serie de Alimentos (Escala Original)", ylab = "Índice", xlab = "Tiempo")
win.graph(); plot(decompose(Datos5, type = "multiplicative")$trend,
                 ylim = c(min(Datos5), max(Datos5)), lwd = 4, main = "Tendencia (descomposición multiplicativa)")

# Análisis de estacionalidad
win.graph(); boxplot(Datos5 ~ cycle(Datos5), main = "Boxplot Estacional por Mes")
win.graph(); periodogram(diff(Datos5), lwd = 4); abline(v = c(1:6) / 12, col = 2, lty = 2) 

# Gráficos de la serie en escala original
win.graph(); plot(Datos5, main = "Serie de Alimentos (Escala Original)", ylab = "Índice", xlab = "Tiempo")
win.graph(); plot(decompose(Datos5, type = "multiplicative")$trend,
                 ylim = c(min(Datos5), max(Datos5)), lwd = 4, main = "Tendencia (descomposición multiplicativa)")

# Análisis de estacionalidad
win.graph(); boxplot(Datos5 ~ cycle(Datos5), main = "Boxplot Estacional por Mes")
win.graph(); periodogram(diff(Datos5), lwd = 4); abline(v = c(1:6) / 12, col = 2, lty = 2)
# Crear matrices de diseño para ajuste y pronóstico
t_ajustado = 1:n
mes = seasonaldummy(yt)
poli1 = Mipoly(tiempo = t_ajustado, grado = 3)
X1 = data.frame(poli1, mes)

mesnuevo = seasonaldummy(yt, h = 12)
poli1nuevo = Mipoly(tiempo = tnuevo, grado = 3)
X1nuevo = data.frame(poli1nuevo, mesnuevo)

# Ajustar y evaluar el modelo 1
modelo1 = lm(log(yt) ~ ., data = X1)
npar1 = length(coef(modelo1)[coef(modelo1) != 0])
Criterios1 = exp.crit.inf.resid(residuales = residuals(modelo1), n.par = npar1)

# Pronóstico y evaluación de precisión del modelo 1
pronmodelo1 = predict(modelo1, newdata = X1nuevo, interval = "prediction", level = 0.95)
ytpron1 = ts(exp(pronmodelo1[, 1]), freq = 12, start = start(ytnuevo))
accuracy(ytpron1, ytnuevo)
Amplcobmodelo1 = amplitud.cobertura(ytnuevo, exp(pronmodelo1[, 2]), exp(pronmodelo1[, 3]))
ScoreIP1 = IntervalScore(ytnuevo, exp(pronmodelo1[, 2]), exp(pronmodelo1[, 3]), alpha = 0.05)

# Gráficos del modelo 1
win.graph(); plot.ts(residuals(modelo1)); abline(h = c(-2 * summary(modelo1)$sigma, 0, 2 * summary(modelo1)$sigma), col = 2)
# Ajustar el modelo 2
modelo2 = regexponencialv02(Datos5[1:n], X1)

# Pronóstico y evaluación de precisión del modelo 2
pronmodelo2 = predict_expo(modelo2, X1nuevo, interval = "prediction", level = 0.95)
ytpron2 = ts(pronmodelo2[, 1], start = start(ytnuevo), freq = 12)
accuracy(ytpron2, ytnuevo)

# Gráficos del modelo 2
win.graph(); plot(Datos5, main = "Ajuste y Pronóstico - Modelo 2 Exponencial", ylab = "Valores de la Serie", xlab = "Tiempo")
lines(ts(fitted(modelo2), start = start(Datos5), freq = 12), col = "blue", lwd = 2)
lines(ts(ytpron2, start = start(ytnuevo), freq = 12), col = "red", lwd = 2)
legend("topleft", legend = c("Original", "Ajuste (Modelo 2)", "Pronóstico"), col = c("black", "blue", "red"), lty = 1, lwd = 2)
win.graph(); plot(residuals(modelo2))
# Ajustar el modelo 3
modelo3 = SuavizamientoEstacional(yt, seasonal = "multiplicative", h = 12, beta = 1e-5, gamma = 1e-5)
ythat3 = fitted(modelo3)
npar3 = (12 - 1) + 2
Criterios3 = exp.crit.inf.resid(residuals(modelo3), n.par = npar3)

# Pronóstico y evaluación de precisión del modelo 3
pronmodelo3 = modelo3$forecast
ytpron3 = ts(pronmodelo3, start = start(ytnuevo), freq = 12)
accuracy(ytpron3, ytnuevo)
Amplcobmodelo3 = amplitud.cobertura(ytnuevo, pronmodelo3[, 2], pronmodelo3[, 3])
ScoreIP3 = IntervalScore(ytnuevo, pronmodelo3[, 2], pronmodelo3[, 3], alpha = 0.05)

# Gráficos del modelo 3
win.graph(); plot(Datos5); lines(ythat3, col = 2, lwd = 2)
legend("topleft", legend = c("Original", "Modelo 3 (HW mult)"), col = c(1, 2), lty = 1)
win.graph(); plot(residuals(modelo3)); abline(h = c(-2 * sqrt(modelo3$MSE), 0, 2 * sqrt(modelo3$MSE)), col = 2)
# Ajustar el modelo 4
modelo4 = Descomp.Loessv02(serie.ajuste = yt, tipo.descomp = "multiplicative", grado = 1, criterio = "gcv", h = 12, level = 0.95)
ythat4 = fitted(modelo4)
npar4 = modelo4$p
Criterios4 = exp.crit.inf.resid(residuals(modelo4), n.par = npar4)

# Pronóstico y evaluación de precisión del modelo 4
pronmodelo4 = modelo4$forecast
ytpron4 = ts(pronmodelo4[, 1], start = start(ytnuevo), freq = 12)
accuracy(ytpron4, ytnuevo)
Amplcobmodelo4 = amplitud.cobertura(ytnuevo, pronmodelo4[, 2], pronmodelo4[, 3])
ScoreIP4 = IntervalScore(ytnuevo, pronmodelo4[, 2], pronmodelo4[, 3], alpha = 0.05)

# Gráficos del modelo 4
win.graph(); plot(Datos5); lines(ythat4, col = 2, lwd = 2)
legend("topleft", legend = c("Original", "Modelo 4 (DLL GCV)"), col = c(1, 2), lty = 1)
win.graph(); plot(residuals(modelo4)); abline(h = c(-2 * sqrt(modelo4$MSE), 0, 2 * sqrt(modelo4$MSE)), col = 2)
# Gráfico comparativo de pronósticos
win.graph()
plot(ytnuevo, xaxt = "n", ylim = c(min(ytnuevo, ytpron1, ytpron2, ytpron3, ytpron4), max(ytnuevo, ytpron1, ytpron2, ytpron3, ytpron4) + 3),
     type = "b", pch = 19, lwd = 3, ylab = "Índice de Precios", xlab = "Periodo de Pronóstico",
     main = "Comparación de Pronósticos")
lines(ytpron1, type = "b", pch = 2, lty = 2, lwd = 3, col = 2)
lines(ytpron2, type = "b", pch = 3, lty = 3, lwd = 3, col = 4)
lines(ytpron3, type = "b", pch = 4, lty = 4, lwd = 3, col = 6)
lines(ytpron4, type = "b", pch = 5, lty = 5, lwd = 3, col = 8)

# Añadir etiquetas de mes en el eje x
axis(1, at = time(ytnuevo), labels = paste0(month.abb[month(ytnuevo)], "-", year(ytnuevo)), cex.axis = 0.7)

legend("topleft", legend = c("Datos Reales", "Modelo 1 (Log-Pol)", "Modelo 2 (Exp-Pol)", "Modelo 3 (HW)", "Modelo 4 (DLL)"),
       col = c(1, 2, 4, 6, 8), pch = c(19, 2, 3, 4, 5), lty = c(1, 2, 3, 4, 5), lwd = 3, bty = "n")
